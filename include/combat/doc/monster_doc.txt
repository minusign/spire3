
好的，这是您提供的 MonsterGroup.h 和 Monster.h 文件的文档说明。

1. MonsterGroup.h 文档
此文档是关于 MonsterGroup.h 文件的，它定义了 sts 命名空间中的 MonsterGroup 结构体，用于管理游戏《Slay the Spire》中战斗时的所有怪物。
文件概览
MonsterGroup.h 封装了当前战斗中所有怪物的集合。它负责怪物的初始化、生命状态跟踪、目标选择辅助以及协调怪物行动。

结构体
MonsterGroup. 结构体表示战斗中的怪物组，管理着所有怪物实例。
成员变量:
    monstersAlive (int): 当前存活的怪物数量。
    monsterCount (int): 怪物组中怪物的总数量。
    arr (std::array<Monster, 5>): 存储 Monster 对象的固定大小数组，最大支持5个怪物。
    extraRollMoveOnTurn (std::bitset<5>): 位集，标记某个怪物是否在本回合额外进行一次行动选择（RollMove）。
    skipTurn (std::bitset<5>): 位集，标记某个怪物是否跳过本回合行动。
查询函数 (const 成员函数):
    areMonstersBasicallyDead() const: 判断所有怪物是否基本死亡（可能指生命值极低或即将死亡）。
    getAliveCount() const: 获取当前存活怪物的数量。
    getTargetableCount() const: 获取当前可被玩家选为目标的怪物数量。
    getFirstTargetable() const: 获取第一个可被玩家选为目标的怪物的索引。
    getRandomMonsterIdx(Random &rng, bool aliveOnly=true) const: 获取一个随机怪物的索引。
初始化函数:
    init(BattleContext &bc, MonsterEncounter encounter): 根据怪物遭遇类型初始化整个怪物组。
    createMonsters(BattleContext &bc, MonsterEncounter encounter): 根据遭遇类型创建具体的怪物实例。
    createMonster(BattleContext &bc, MonsterId id): 创建一个指定ID的怪物实例并添加到组中。
    createStrongHumanoid(BattleContext &bc): 创建强大的类人生物（例如，高阶奴隶主）。
    createStrongWildlife(BattleContext &bc): 创建强大的野生生物（例如，大型史莱姆）。
    createWeakWildlife(BattleContext &bc): 创建弱小的野生生物（例如，小地精、小史莱姆）。
    createShapes(BattleContext &bc, int count): 创建指定数量的形状怪物。

静态辅助函数 (怪物ID获取):
static MonsterId getAncientShape(Random &miscRng): 获取一个随机的远古形状怪物ID。
static MonsterId getGremlin(Random &rng): 获取一个随机的地精怪物ID。
static MonsterId getLouse(Random &miscRng): 获取一个随机的虱子怪物ID。
static MonsterId getSlaver(Random &miscRng): 获取一个随机的奴隶主怪物ID。

怪物行动函数:
doMonsterTurn(BattleContext &bc): 协调下一个怪物执行其回合行动。
applyPreTurnLogic(BattleContext &bc): 应用怪物回合开始前的逻辑（例如，遗物效果）。
applyEmeraldEliteBuff(BattleContext &bc, int buffType, int act): 应用精英怪物的翡翠精英增益。

运算符重载:
std::ostream &operator<<(std::ostream &os, const MonsterGroup &g): 重载输出运算符，用于打印 MonsterGroup 对象的信息。

2. Monster.h 文档
此文档是关于 Monster.h 文件的，它定义了 sts 命名空间中的 Monster 结构体和 DamageInfo 结构体，
    用于表示游戏《Slay the Spire》中单个怪物的状态、属性和行为。   
文件概览
Monster.h 定义了 Monster 结构体，它包含了单个怪物的所有运行时数据，如生命值、格挡、各种状态效果、移动历史和独特的行为数据。
    它还提供了修改这些属性、处理怪物行动以及响应玩家交互的方法。

    
结构体
DamageInfo. 结构体用于存储伤害信息，特别是当攻击是多段伤害时。
成员变量:
    damage (int): 造成的单次伤害或总伤害。
    attackCount (int): 攻击的次数（例如多段攻击）。

Monster. 结构体表示战斗中的单个怪物实例。

核心属性:
    idx (int): 怪物的索引（在 MonsterGroup 数组中的位置）。
    id (MonsterId): 怪物的基本ID，定义了怪物的类型和原始属性。
    curHp (int): 怪物的当前生命值。
    maxHp (int): 怪物的最大生命值。
    block (int): 怪物的当前格挡值。
    isEscapingB (bool): 怪物是否正在逃跑。
    halfDead (bool): 怪物是否处于半死状态（例如，一些精英怪物的第二阶段）。
    escapeNext (bool): 怪物是否在下一个回合逃跑。
    moveHistory[2] (MMID): 怪物最近两次的行动ID。
状态效果 (MonsterStatus):
    statusBits (std::uint64_t): 位集，用于快速检查怪物是否拥有某个状态。
    artifact (std::int8_t): 人工制品层数。
    blockReturn (std::int8_t): 格挡返回层数。
    choked (std::int8_t): 窒息层数。
    corpseExplosion (std::int8_t): 尸爆层数。
    lockOn (std::int8_t): 锁定层数。
    mark (std::int16_t): 标记层数。
    metallicize (std::int8_t): 金属化层数。
    platedArmor (std::int8_t): 镀甲层数。
    poison (std::int8_t): 中毒层数。
    regen (std::int8_t): 再生层数。
    shackled (std::int8_t): 束缚层数。
    strength (int): 力量层数。
    vulnerable (int): 易伤层数。
    weak (int): 虚弱层数。
独特力量/杂项信息 (根据怪物类型有不同含义):
    uniquePower0 (int): 通用独特力量计数器0（例如六火亡魂的火球数）。
    uniquePower1 (std::int16_t): 通用独特力量计数器1（例如腐化之心的无敌）。
    miscInfo (int): 杂项信息（例如盾牌地精的目标、地精巫师充能、时间吞噬者加速等）。
构造函数:
    Monster(): 默认构造函数。
    Monster(const Monster& rhs): 拷贝构造函数。
初始化函数:
    setRandomHp(Random &hpRng, bool higherHp): 根据随机数设置随机生命值。
    initHp(Random &hpRng, int ascension): 根据进阶等级和随机数初始化生命值。
    construct(BattleContext &bc, MonsterId monsterId, int monsterIdx): 构造怪物实例。
    initSpawnedMonster(BattleContext &bc, MonsterId monsterId, int monsterIdx, int hp): 初始化生成的怪物。
    preBattleAction(BattleContext &bc): 战斗前行动。
回合生命周期函数:
    applyStartOfTurnPowers(BattleContext &bc): 应用回合开始的力量效果。
    applyEndOfTurnTriggers(BattleContext &bc): 应用回合结束的触发效果。
    applyEndOfRoundPowers(BattleContext &bc): 应用回合结束的力量效果（用于持续性效果）。
查询函数 (const 成员函数):
    getName() const: 获取怪物的名称。
    hasStatusInternal(MonsterStatus s) const: 内部使用，判断怪物是否拥有状态。
    getStatusInternal(MonsterStatus s) const: 内部使用，获取怪物状态的值。
    template <MonsterStatus> [[nodiscard]] bool hasStatus() const: 判断怪物是否拥有指定状态。
    template <MonsterStatus> [[nodiscard]] int getStatus() const: 获取怪物指定状态的层数。
    template <MonsterStatus> [[nodiscard]] bool wasJustApplied() const: 判断指定状态是否是本回合刚施加的。
    isAlive() const: 判断怪物是否存活。
    isTargetable() const: 判断怪物是否可被玩家选为目标。
    isDying() const: 判断怪物是否正在死亡。
    isEscaping() const: 判断怪物是否正在逃跑。
    isDeadOrEscaped() const: 判断怪物是否死亡或已逃跑。
    isHalfDead() const: 判断怪物是否处于半死状态。
    doesEscapeNext() const: 判断怪物是否在下回合逃跑。
    isAttacking() const: 判断怪物是否正在攻击。
    firstTurn() const: 判断是否是怪物的第一回合。
    lastMove(MonsterMoveId moveId) const: 判断上一次行动是否为指定行动。
    lastMoveBefore(MonsterMoveId moveId) const: 判断上上一次行动是否为指定行动。
    lastTwoMoves(MonsterMoveId moveId) const: 判断最近两次行动是否都为指定行动。
    eitherLastTwo(MonsterMoveId moveId) const: 判断最近两次行动中是否有一次为指定行动。
    getMoveForRoll(BattleContext &bc, int &monsterData, int roll) const: 根据骰子结果和怪物数据获取怪物的下一个行动ID。
    calculateDamageToPlayer(const BattleContext &bc, int baseDamage) const: 计算对玩家造成的最终伤害。
    getMoveBaseDamage(const BattleContext &bc) const: 获取怪物行动的基础伤害信息。
修改函数:
    template <MonsterStatus> void setHasStatus(bool value=true): 设置怪物是否拥有指定状态。
    template <MonsterStatus> void setStatus(int amount): 设置怪物指定状态的层数。
    template <MonsterStatus> void decrementStatus(int amount=1): 减少怪物指定状态的层数。
    template <MonsterStatus> void addDebuff(int amount, bool isSourceMonster=true): 对怪物施加减益效果。
    template <MonsterStatus> void removeStatus(): 移除怪物指定状态。
    template <MonsterStatus> void buff(int amount=1): 对怪物施加增益效果。
    template <MonsterStatus> void setJustApplied(bool value): 设置指定状态的 justApplied 标志。
    heal(int amount): 治疗怪物生命值。
    addBlock(int amount): 怪物获得格挡。
    die(BattleContext &bc): 怪物死亡。
    suicideAction(BattleContext &bc): 怪物自杀。
    attackedUnblockedHelper(BattleContext &bc, int damage): 未格挡攻击的辅助处理。
    attacked(BattleContext &bc, int damage): 怪物受到攻击。
    damageUnblockedHelper(BattleContext &bc, int damage): 未格挡伤害的辅助处理。
    damage(BattleContext &bc, int damage): 怪物受到伤害。
    onHpLost(BattleContext &bc, int amount): 怪物生命值损失后调用。
    removeDebuffs(): 移除怪物的减益。
    resetAllStatusEffects(): 重置所有状态效果。
    setMove(MonsterMoveId moveId): 设置怪物的当前行动。
怪物回合与行为:
    rollMove(BattleContext &bc): 怪物选择下一个行动。
    attackPlayerHelper(BattleContext &bc, int baseDamage, int times=1): 怪物攻击玩家的辅助函数。
    takeTurn(BattleContext &bc): 怪物执行其回合行动。
怪物特定函数:
    stealGoldFromPlayer(BattleContext &bc, int amount): 从玩家那里偷取金币。
    static void largeSlimeSplit(BattleContext &bc, MonsterId mediumSlimeType, int placeIdx, int hp): 大型史莱姆分裂。
    static void slimeBossSplit(BattleContext &bc, int hp): 史莱姆王分裂。
    spawnBronzeOrbs(BattleContext &bc): “青铜自动化”召唤青铜法球。
    stasisAction(BattleContext &bc): “青铜法球”的静滞行动。
    returnStasisCard(BattleContext &bc): 返回静滞卡牌。
    reptomancerSummon(BattleContext &bc, int daggerCount): “爬行者”召唤匕首。
    static int getAliveGremlinCount(const BattleContext &bc): 获取存活地精的数量。
运算符重载:
std::ostream& operator<<(std::ostream &os, const sts::Monster &m): 重载输出运算符，用于打印 Monster 对象的信息。


MonsterGroup.h 和 Monster.h 之间的关系
这两个文件是紧密关联的，共同负责游戏中怪物的完整管理系统：
集合与个体:
MonsterGroup (集合) 负责管理当前战斗中的所有 Monster (个体) 实例。它维护着一个 std::array<Monster, 5> arr 来存储这些个体怪物，并跟踪 monstersAlive 和 monsterCount 等整体统计信息。
Monster (个体) 结构体则定义了单个怪物的具体属性（如生命值、状态、移动历史）和行为。
初始化与创建:
MonsterGroup::init() 和 MonsterGroup::createMonsters() 等方法负责根据遭遇类型，
    创建具体的 Monster 实例，并将它们添加到 MonsterGroup 的 arr 数组中。
Monster::construct() 和 Monster::initSpawnedMonster() 则是在 MonsterGroup 调用时，
    初始化单个 Monster 实例的详细信息，例如生命值、ID和索引。

回合行动协调:
MonsterGroup::doMonsterTurn() 是驱动怪物回合的核心函数。它会迭代其内部的 Monster 数组，并为当前应该行动的怪物调用 Monster::takeTurn() 方法。
Monster::takeTurn() 负责执行单个怪物的具体行动逻辑，包括选择
    移动（Monster::rollMove()）和执行该移动所带来的效果（如攻击玩家 Monster::attackPlayerHelper() 或施加状态 Monster::addDebuff()）。
Monster::rollMove() 会根据怪物的状态和随机数，决定怪物本回合将执行哪个特定的 MonsterMoveId。

状态与生命周期管理:
MonsterGroup::areMonstersBasicallyDead() 和 MonsterGroup::getAliveCount() 等函数用于检查怪物组的整体生命状态，并影响战斗的结束条件。
Monster::die() 是单个怪物死亡时的处理函数，它会触发死亡相关的效果，并可能影响 MonsterGroup 中的 monstersAlive 计数。
Monster::buff(), Monster::debuff(), Monster::heal(), Monster::damage() 等方法直接修改单个 Monster 的属性和状态。
    这些修改会影响到 MonsterGroup 在计算目标或存活怪物时的结果。

跨文件交互:
许多 Monster 的方法（如 damage()、die()）都需要 BattleContext 的引用，因为怪物的行动会影响整个战斗状态，
    例如对玩家造成伤害、向行动队列添加新行动等。
MonsterGroup 在其初始化和行动协调中也大量依赖 BattleContext 来获取全局信息或添加行动。
总而言之，MonsterGroup 是怪物们的“管家”，负责整体的调度和管理，
    而 Monster 则是具体的“个体”，拥有自身的属性和行为逻辑。
    两者通过相互调用和 BattleContext 这个中央枢纽，共同模拟了《Slay the Spire》中怪物在战斗中的复杂互动。